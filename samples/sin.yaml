light:
  - num_leds: 256
    effects:
      - addressable_lambda:
          name: "half_sin8"
          lambda: |-
            // Highest performance 8 bits sinf() equivalent at significantly
            // lower quality.
            const auto leds = it.size();
            for (int i = 0; i < leds; i++) {
              auto v = 2*half_sin8(i);
              it[i].set(Color(v, v, v));
            }
      - addressable_lambda:
          name: "sin16_c"
          lambda: |-
            // High performance 16 bits sinf() equivalent at reasonable quality.
            const auto leds = it.size();
            for (int i = 0; i < leds; i++) {
              auto v = sin16_c(i*32767/leds);
              it[i].set(Color(v>>7, v>>7, v>>7));
            }
      - addressable_lambda:
          name: "sinf"
          lambda: |-
            // floating point based sin calculation. Benchmarking this on a
            // desktop class CPU will not provide meaningful results since the
            // ESP32 doesn't have floating acceleration.
            const auto leds = it.size();
            const auto factor = M_PIf/leds;
            for (int i = 0; i < leds; i++) {
              auto c = (uint8_t)(255.f*sinf(factor*i));
              it[i].set(Color(c, c, c));
            }
      - addressable_lambda:
          name: "sinf_saturated"
          lambda: |-
            // floating point based sin calculation. Benchmarking this on a
            // desktop class CPU will not provide meaningful results since the
            // ESP32 doesn't have floating acceleration.
            const auto leds = it.size();
            const auto factor = M_PIf/leds;
            for (int i = 0; i < leds; i++) {
              // Saturate the output significantly more with the +0.5f bump.
              auto c = (uint8_t)(255.f*sinf(factor*i)+0.5f);
              it[i].set(Color(c, c, c));
            }
