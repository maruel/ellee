light:
  - num_leds: 256
    gamma_correct: 0
    default_transition_length: 0s
    effects:
      - addressable_lambda:
          name: "Impulse"
          lambda: |-
            // A linear approximation of an ASRD (attack + sustain + release
            // + decay) impulse to use in an animation as a lambda.
            auto impulse = [](uint16_t index, uint16_t max = 255, uint16_t attack = 10, uint16_t sustain = 10, uint16_t release = 80, uint16_t releaselevel = 30, uint16_t remainder = 156) {
              if (index < attack) {
                return uint16_t((index+1) * max / (attack+1));
              }
              index -= attack;
              if (index < sustain) {
                return max;
              }
              index -= sustain;
              if (index < release) {
                return (uint16_t)(((max-releaselevel) * (release-index) / release) + releaselevel);
              }
              index -= release;
              return (uint16_t)(releaselevel * (remainder-index) / remainder);
            };

            const auto leds = it.size();
            for (int i = 0; i < leds; i++) {
              auto v = impulse(i);
              it[i].set(Color(v, v, v));
            }
      - addressable_lambda:
          name: "Precomputed impulse"
          lambda: |-
            // Precalculate a linear approximation of an ASRD (attack + sustain
            // + release + decay) impulse to use in an animation as a
            // table lookup. Settings:
            const int max = 255;
            const int attack = 10;
            const int sustain = 10;
            const int release = 80;
            const int releaselevel = 30;
            static uint8_t impulse[256];
            // Do not use initial_run otherwise this would be recalculated every
            // single time this effect is started.
            if (impulse[1] == 0) {
              const auto remainder = sizeof(impulse) - attack - sustain - release;
              for (int i = 0; i < sizeof(impulse); i++) {
                auto v = i;
                if (v < attack) {
                  impulse[i] = (v+1) * max / (attack+1);
                  continue;
                }
                v -= attack;
                if (v < sustain) {
                  impulse[i] = max;
                  continue;
                }
                v -= sustain;
                if (v < release) {
                  impulse[i] = ((max-releaselevel) * (release-v) / release) + releaselevel;
                  continue;
                }
                v -= release;
                impulse[i] = releaselevel * (remainder-v) / remainder;
              }
            }

            const auto leds = it.size();
            for (int i = 0; i < leds; i++) {
              it[i].set(Color(impulse[i], impulse[i], impulse[i]));
            }
