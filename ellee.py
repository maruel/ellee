#!/usr/bin/env python3
# Copyright 2024 Marc-Antoine Ruel. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

"""Runs a display effect locally for faster iteration."""

import argparse
import os
import shutil
import subprocess
import sys
import textwrap

import yaml

HEADER = r"""// Generated by ellee.py

#include "esphome/components/light/addressable_light.h"

void update(esphome::light::AddressableLight &it, bool initial_run) {
  using namespace esphome;
  using namespace esphome::light;
  // Beginning of lambda.
"""

FOOTER = r"""
  // End of lambda.
}

// Support code.

class ElleeLight : public esphome::light::AddressableLight {
  public:
    ElleeLight() {
      correction_.calculate_gamma_table(1);
    }
    virtual esphome::light::LightTraits get_traits() {
      auto traits = esphome::light::LightTraits();
      traits.set_supported_color_modes({esphome::light::ColorMode::RGB});
      return traits;
    }
    virtual int32_t size() const {
      return %(NUMLIGHTS)d;
    }
    virtual void clear_effect_data() {
      memset(effect_data_, 0, sizeof(effect_data_));
    }
    virtual esphome::light::ESPColorView get_view_internal(int32_t index) const {
      return esphome::light::ESPColorView(
          &pixels_[3*index], &pixels_[3*index+1], &pixels_[3*index+2],
          nullptr, (uint8_t*)&effect_data_, &correction_);
    }
    virtual void write_state(esphome::light::LightState *state) {
      // Switch to help debugging.
      write_ansi();
      //write_hex();
    }
    void write_ansi() {
      printf("\r");
      printf("\x1b[0m");
      //printf("%%- 11d ", esphome::millis());
      for (int i = 0; i < size(); i++) {
        printf("\x1b[38;2;%%d;%%d;%%dm\u2588", pixels_[3*i], pixels_[3*i+1], pixels_[3*i+2]);
      }
      printf("\x1b[0m");
      //printf("\n");
    }
    void write_hex() {
      printf("\r");
      //printf("%%- 11d ", esphome::millis());
      for (int i = 0; i < size(); i++) {
        printf("%%02x%%02x%%02x", pixels_[3*i], pixels_[3*i+1], pixels_[3*i+2]);
        if (i != size()-1) {
          printf(" ");
        }
      }
      //printf("\n");
    }

    mutable uint8_t pixels_[3*%(NUMLIGHTS)d];
    mutable uint8_t effect_data_[%(NUMLIGHTS)d];
};

ElleeLight it;
bool g_initial_run = true;

void setup() {
  printf("Running %%s/%%s:\n", "%(COMPONENTNAME)s", "%(EFFECTNAME)s");
}

void loop() {
  update(it, g_initial_run);
  g_initial_run = false;
  it.write_state(nullptr);
  esphome::delay(%(INTERVAL)d);
}
"""

def escape(r):
  return r.replace("\\", "\\\\").replace("\"", "\\\"")

def generate_effect(esphome, slow, componentname, numlights, effectname, interval, code):
  print("Compiling effect %s on item %r" % (effectname, componentname))
  if slow:
    interval = 500
  elif not interval:
    interval = "32"
  elif interval.endswith("ms"):
    interval = int(interval[:-2])
  elif interval.endswith("s"):
    interval = int(interval[:-1]) * 1000
  else:
    raise Exception("Unknown interval")

  keys = {
      "COMPONENTNAME": escape(componentname),
      "EFFECTNAME": escape(effectname),
      "NUMLIGHTS": int(numlights),
      "INTERVAL": interval,
  }
  with open("run.cc", "wt") as f:
    f.write(HEADER % keys)
    f.write(textwrap.indent(code.rstrip(), "  "))
    f.write(FOOTER % keys)
  # We need to inject a little bit of code.
  files = [
      "run.cc",
      os.path.join(esphome, "esphome/components/host/core.cpp"),
      os.path.join(esphome, "esphome/components/host/preferences.cpp"),
      os.path.join(esphome, "esphome/components/light/addressable_light.cpp"),
      os.path.join(esphome, "esphome/components/light/esp_color_correction.cpp"),
      os.path.join(esphome, "esphome/components/light/esp_range_view.cpp"),
      os.path.join(esphome, "esphome/components/light/light_call.cpp"),
      os.path.join(esphome, "esphome/components/light/light_output.cpp"),
      os.path.join(esphome, "esphome/components/light/light_state.cpp"),
      os.path.join(esphome, "esphome/core/application.cpp"),
      os.path.join(esphome, "esphome/core/color.cpp"),
      os.path.join(esphome, "esphome/core/component.cpp"),
      os.path.join(esphome, "esphome/core/entity_base.cpp"),
      os.path.join(esphome, "esphome/core/helpers.cpp"),
      os.path.join(esphome, "esphome/core/scheduler.cpp"),
  ]
  subprocess.check_call(["g++", "-ggdb", "-DUSE_HOST", "-I.", "-I" + esphome] + files)
  print("Run ./a.out or gdb ./a.out if you are diagnosing a crash")

def parse_light(esphome, slow, item):
  if "effects" not in item:
    return
  for e in item["effects"]:
    for t, data in e.items():
      if t != "addressable_lambda":
        continue
      generate_effect(esphome, slow, item["name"], item["num_leds"], data["name"],
                      data["update_interval"], data["lambda"])

def main():
  if not shutil.which("g++"):
    print("Install g++ first", file=sys.stderr)
    return 1
  parser = argparse.ArgumentParser(description=sys.modules[__name__].__doc__)
  parser.add_argument(
      "file", type=argparse.FileType("r"), help="esphome yaml file to parse")
  parser.add_argument(
      "--esphome", required=True,
      metavar="path/to/esphome.git",
      help="Path to esphome source code")
  parser.add_argument(
      "--slow", action="store_true", help="Slows down update interval to once per 500ms")
  args = parser.parse_args()
  if not os.path.isfile(os.path.join(args.esphome, "esphome", "core", "color.cpp")):
    print("--esphome must point to a checkout of https://github.com/esphome/esphome", file=sys.stderr)
    return 1
  # Use BaseLoader to not have to resolve !include.
  data = yaml.load(args.file, Loader=yaml.BaseLoader)
  for item in data.get("display", []):
    parse_light(args.esphome, args.slow, item)
  for item in data.get("light", []):
    parse_light(args.esphome, args.slow, item)
  return 0

if __name__ == "__main__":
  sys.exit(main())
