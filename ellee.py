#!/usr/bin/env python3
# Copyright 2024 Marc-Antoine Ruel. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

"""Runs a display effect locally for faster iteration."""

import argparse
import os
import shutil
import subprocess
import sys
import textwrap

import yaml

HEADER = r"""// Generated by ellee.py

#include "esphome/components/light/addressable_light.h"

void update(esphome::light::AddressableLight &it, bool initial_run) {
  using namespace esphome;
  using namespace esphome::light;
  // Beginning of lambda.
"""

FOOTER = r"""
  // End of lambda.
}

// Support code.

class ElleeLight : public esphome::light::AddressableLight {
  public:
    ElleeLight() {
      correction_.calculate_gamma_table(1);
    }
    virtual esphome::light::LightTraits get_traits() {
      auto traits = esphome::light::LightTraits();
      traits.set_supported_color_modes({esphome::light::ColorMode::RGB});
      return traits;
    }
    virtual int32_t size() const {
      return %(NUMLIGHTS)d;
    }
    virtual void clear_effect_data() {
      memset(effect_data_, 0, sizeof(effect_data_));
    }
    virtual esphome::light::ESPColorView get_view_internal(int32_t index) const {
      return esphome::light::ESPColorView(
          &pixels_[3*index], &pixels_[3*index+1], &pixels_[3*index+2],
          nullptr, (uint8_t*)&effect_data_, &correction_);
    }
    virtual void write_state(esphome::light::LightState *state) {
      // Switch to help debugging.
      if (%(AS_HEX)s) {
        write_hex();
      } else {
        write_ansi();
      }
      fflush(stdout);
    }
    void write_ansi() {
      printf("\r");
      printf("\x1b[0m");
      if (%(SHOW_MILLIS)s) {
        printf("%%- 11d ", esphome::millis());
      }
      for (int i = 0; i < size(); i++) {
        printf("\x1b[38;2;%%d;%%d;%%dm\u2588", pixels_[3*i], pixels_[3*i+1], pixels_[3*i+2]);
      }
      printf("\x1b[0m");
      if (%(ONE_PER_LINE)s) {
        printf("\n");
      }
    }
    void write_hex() {
      printf("\r");
      if (%(SHOW_MILLIS)s) {
        printf("%%- 11d ", esphome::millis());
      }
      for (int i = 0; i < size(); i++) {
        printf("%%02x%%02x%%02x", pixels_[3*i], pixels_[3*i+1], pixels_[3*i+2]);
        if (i != size()-1) {
          printf(" ");
        }
      }
      if (%(ONE_PER_LINE)s) {
        printf("\n");
      }
    }

    mutable uint8_t pixels_[3*%(NUMLIGHTS)d];
    mutable uint8_t effect_data_[%(NUMLIGHTS)d];
};

ElleeLight it;
bool g_initial_run = true;

void setup() {
  printf("Effect %%s:\n", "%(EFFECTNAME)s");
}

void loop() {
  update(it, g_initial_run);
  g_initial_run = false;
  it.write_state(nullptr);
  esphome::delay(%(INTERVAL)d);
}
"""

def escape(r):
  return r.replace("\\", "\\\\").replace("\"", "\\\"")

def generate_effect(
    esphome, outdir,
    min_interval, one_per_line, as_hex, show_millis,
    componentname, numlights, effectname, interval, code):
  exe = os.path.join(outdir, effectname.translate(str.maketrans({x: "_" for x in " []{}\\/^$*?"})))
  print("Compiling effect \"%s/%s\" to %s " % (componentname, effectname, exe))
  if not interval:
    interval = 50
  elif interval.endswith("ms"):
    interval = int(interval[:-2])
  elif interval.endswith("s"):
    interval = int(interval[:-1]) * 1000
  else:
    raise Exception("Unknown interval")
  interval = max(min_interval, interval)

  keys = {
      "EFFECTNAME": escape(effectname),
      "INTERVAL": interval,
      "NUMLIGHTS": int(numlights),
      "ONE_PER_LINE": str(one_per_line).lower(),
      "AS_HEX": str(as_hex).lower(),
      "SHOW_MILLIS": str(show_millis).lower(),
  }
  with open(exe+".cc", "wt") as f:
    f.write(HEADER % keys)
    f.write(textwrap.indent(code.rstrip(), "  "))
    f.write(FOOTER % keys)
  # We need to inject a little bit of code.
  files = [
      exe+".cc",
      os.path.join(esphome, "esphome/components/host/core.cpp"),
      os.path.join(esphome, "esphome/components/host/preferences.cpp"),
      os.path.join(esphome, "esphome/components/light/addressable_light.cpp"),
      os.path.join(esphome, "esphome/components/light/esp_color_correction.cpp"),
      os.path.join(esphome, "esphome/components/light/esp_range_view.cpp"),
      os.path.join(esphome, "esphome/components/light/light_call.cpp"),
      os.path.join(esphome, "esphome/components/light/light_output.cpp"),
      os.path.join(esphome, "esphome/components/light/light_state.cpp"),
      os.path.join(esphome, "esphome/core/application.cpp"),
      os.path.join(esphome, "esphome/core/color.cpp"),
      os.path.join(esphome, "esphome/core/component.cpp"),
      os.path.join(esphome, "esphome/core/entity_base.cpp"),
      os.path.join(esphome, "esphome/core/helpers.cpp"),
      os.path.join(esphome, "esphome/core/scheduler.cpp"),
  ]
  subprocess.check_call(["g++", "-ggdb", "-o", exe, "-DUSE_HOST", "-I.", "-I" + esphome] + files)
  print(f"Run \"{exe}\" or \"gdb {exe}\" to diagnose a crash")

def parse_light(esphome, outdir, min_interval, one_per_line, as_hex,
                show_millis, item):
  if "effects" not in item:
    return
  for e in item["effects"]:
    for t, data in e.items():
      if t != "addressable_lambda":
        continue
      generate_effect(
          esphome, outdir,
          min_interval, one_per_line, as_hex, show_millis,
          item["name"], item["num_leds"], data["name"],
          data["update_interval"], data["lambda"])

def main():
  if not shutil.which("g++"):
    print("Install g++ first", file=sys.stderr)
    return 1
  parser = argparse.ArgumentParser(description=sys.modules[__name__].__doc__)
  parser.add_argument(
      "file", type=argparse.FileType("r"), help="esphome yaml file to parse")
  parser.add_argument(
      "--esphome", required=True,
      metavar="path/to/esphome.git",
      help="Path to esphome source code")
  parser.add_argument(
      "--outdir", default=".", metavar=".",
      help="Directory to store generated source and executabe")
  parser.add_argument(
      "--interval", type=int, default=0, help="Minimal interval in ms to use")
  parser.add_argument(
      "--show-millis", action="store_true",
      help="Display time in millis before the colors")
  parser.add_argument(
      "--as-hex", action="store_true",
      help="Display hex values instead of using ANSI colors")
  parser.add_argument(
      "--one-per-line", action="store_true",
      help="Draw each update on a new line")
  args = parser.parse_args()
  if not os.path.isfile(os.path.join(args.esphome, "esphome", "core", "color.cpp")):
    print("--esphome must point to a checkout of https://github.com/esphome/esphome", file=sys.stderr)
    return 1
  # Use BaseLoader to not have to resolve !include.
  data = yaml.load(args.file, Loader=yaml.BaseLoader)
  for item in data.get("display", []):
    parse_light(args.esphome, args.outdir, args.interval, args.one_per_line,
                args.as_hex, args.show_millis, item)
  for item in data.get("light", []):
    parse_light(args.esphome, args.outdir, args.interval, args.one_per_line,
                args.as_hex, args.show_millis, item)
  return 0

if __name__ == "__main__":
  sys.exit(main())
