#!/usr/bin/env python3
# Copyright 2024 Marc-Antoine Ruel. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

"""Runs a display effect locally for faster iteration."""

import argparse
import os
import subprocess
import sys
import textwrap

import yaml

HEADER = r"""// Generated by ellee.py

#include <stdio.h>
#include "esphome/components/light/addressable_light.h"

using namespace esphome;
using namespace esphome::light;

void update(AddressableLight &it) {
  // Uncomment this line to diagnose issues:
  // printf("Update\n");
"""

FOOTER = r"""}

class Light : public AddressableLight {
  public:
    virtual LightTraits get_traits() {
      return LightTraits{};
    }
    virtual void write_state(LightState *state) {
    }
    virtual int32_t size() const {
      return %(NUMLIGHTS)s;
    }
    virtual void clear_effect_data() {
    }
    virtual ESPColorView get_view_internal(int32_t index) const {
      return ESPColorView(
        &pixels_[3*index], &pixels_[3*index+1], &pixels_[3*index+2],
        NULL, (uint8_t*)&effect_data_, &correction_);
    }
  mutable uint8_t pixels_[3*%(NUMLIGHTS)s];
  mutable uint8_t effect_data_[%(NUMLIGHTS)s];
};

Light it;

void setup() {
  printf("It works\n");
}

void loop() {
  update(it);
  delay(1000);
}
"""
def generate_effect(esphome, itemname, numlights, effectname, code):
  print("Compiling effect %s on item %r" % (effectname, itemname))
  with open("run.cc", "wt") as f:
    f.write(HEADER % {"NUMLIGHTS": numlights})
    f.write(textwrap.indent(code, "  "))
    f.write(FOOTER % {"NUMLIGHTS": numlights})
  # We need to inject a little bit of code.
  files = [
      "run.cc",
      os.path.join(esphome, "esphome/components/host/core.cpp"),
      os.path.join(esphome, "esphome/components/host/preferences.cpp"),
      os.path.join(esphome, "esphome/components/light/addressable_light.cpp"),
      os.path.join(esphome, "esphome/components/light/esp_color_correction.cpp"),
      os.path.join(esphome, "esphome/components/light/esp_range_view.cpp"),
      os.path.join(esphome, "esphome/components/light/light_call.cpp"),
      os.path.join(esphome, "esphome/components/light/light_output.cpp"),
      os.path.join(esphome, "esphome/components/light/light_state.cpp"),
      os.path.join(esphome, "esphome/core/application.cpp"),
      os.path.join(esphome, "esphome/core/component.cpp"),
      os.path.join(esphome, "esphome/core/entity_base.cpp"),
      os.path.join(esphome, "esphome/core/scheduler.cpp"),
      os.path.join(esphome, "esphome/core/color.cpp"),
      os.path.join(esphome, "esphome/core/helpers.cpp"),
  ]
  subprocess.check_call([
    "g++",
    "-ggdb",
    "-DUSE_HOST",
    "-I.",
    "-I" + esphome,
    ] + files)
  print("Run ./a.out or gdb ./a.out if you are diagnosing a crash")

def parse_light(esphome, item):
  if "effects" not in item:
    return
  for e in item["effects"]:
    for t, data in e.items():
      if t != "addressable_lambda":
        continue
      generate_effect(esphome, item["name"], item["num_leds"], data["name"], data["lambda"])

def main():
  parser = argparse.ArgumentParser(description=sys.modules[__name__].__doc__)
  parser.add_argument(
      "file", type=argparse.FileType("r"), help="esphome yaml file to parse")
  parser.add_argument(
      "--esphome", required=True,
      metavar="path/to/esphome.git",
      help="Path to esphome source code")
  args = parser.parse_args()
  if not os.path.isfile(os.path.join(args.esphome, "esphome", "core", "color.cpp")):
    print("--esphome must point to a checkout of https://github.com/esphome/esphome", file=sys.stderr)
    return 1
  # Use BaseLoader to not have to resolve !include.
  data = yaml.load(args.file, Loader=yaml.BaseLoader)
  for item in data.get("display", []):
    parse_light(args.esphome, item)
  for item in data.get("light", []):
    parse_light(args.esphome, item)
  return 0

if __name__ == "__main__":
  sys.exit(main())
